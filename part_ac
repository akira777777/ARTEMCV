      const colors = [
        'rgba(14, 165, 233',  // Sky Blue
        'rgba(16, 185, 129',  // Emerald
        'rgba(245, 158, 11',  // Amber
        'rgba(139, 92, 246'   // Violet
      ];

      for (let i = 0; i < count; i++) {
        // Find inactive particle in pool
        if (activeParticleCount < PARTICLE_POOL_SIZE) {
          const p = particlePool[activeParticleCount++];
          const angle = (Math.random() * Math.PI * 2);
          const speed = 1 + Math.random() * 2;

          // Reset particle properties
          p.x = x;
          p.y = y;
          p.vx = Math.cos(angle) * speed;
          p.vy = Math.sin(angle) * speed;
          p.radius = 1 + Math.random() * 3;
          p.color = colors[Math.floor(Math.random() * colors.length)];
          p.life = 100;
          p.maxLife = 100;
        }
      }
    };

    // Enhanced mouse throttling with timestamp-based approach for better performance
    let lastMouseMoveTime = 0;
    const MOUSE_THROTTLE_DELAY = 16; // ~60fps limit
    let pendingMouseMove = false;
    let mouseAnimationId: number | null = null;

    const updateMousePosition = (clientX: number, clientY: number) => {
      const rect = canvas.getBoundingClientRect();
      mouseRef.current = {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    };

    const handleMouseMove = (e: MouseEvent) => {
      const currentTime = performance.now();

      // Throttle mouse events to prevent excessive processing
      if (currentTime - lastMouseMoveTime < MOUSE_THROTTLE_DELAY) {
        // Store the latest mouse position for next frame processing
        if (!pendingMouseMove) {
          pendingMouseMove = true;
          // Use microtask to ensure we process the latest position
