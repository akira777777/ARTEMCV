        const alphaIdx = Math.min(Math.floor(alphaNorm * ALPHA_STEPS), ALPHA_STEPS - 1);
        batches[p.colorIdx][alphaIdx].push(i);
      }

      // Draw batched particles
      for (let c = 0; c < COLORS.length; c++) {
        const baseColor = COLORS[c];
        for (let a = 0; a < ALPHA_STEPS; a++) {
          const indices = batches[c][a];
          if (indices.length === 0) continue;

          const alpha = (a + 1) / ALPHA_STEPS * 0.8;

          // Draw Glow Layer (combined)
          ctx.beginPath();
          ctx.fillStyle = `${baseColor}, ${alpha * 0.3})`;
          for (const idx of indices) {
            const p = pool[idx];
            ctx.moveTo(p.x + p.radius * 2, p.y);
            ctx.arc(p.x, p.y, p.radius * 2, 0, Math.PI * 2);
          }
          ctx.fill();

          // Draw Core Layer (combined)
          ctx.beginPath();
          ctx.fillStyle = `${baseColor}, ${alpha})`;
          for (const idx of indices) {
            const p = pool[idx];
            ctx.moveTo(p.x + p.radius, p.y);
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          }
          ctx.fill();
        }
      }
    };

    const drawHoverGlow = () => {
      if (!isHovered) return;

      const glow = ctx.createRadialGradient(mouseRef.current.x, mouseRef.current.y, 0, mouseRef.current.x, mouseRef.current.y, 100);
      glow.addColorStop(0, 'rgba(14, 165, 233, 0.3)');
      glow.addColorStop(1, 'rgba(16, 185, 129, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, w, h);

      ctx.strokeStyle = 'rgba(14, 165, 233, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(mouseRef.current.x, mouseRef.current.y, 30, 0, Math.PI * 2);
      ctx.stroke();
